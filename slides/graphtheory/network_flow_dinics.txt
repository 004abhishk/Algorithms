Hello and welcome,
My name is William, and today we're still talking about network flow, and in
particular we're look at maximum flow and unweighted bipartite matching. 
Dinic's algorithm is one of those extremely fast and revolutionary algorithms
which really pushed the field of network flow forwards. It was one, if not the
first algorithm to introduce a bunch of new concepts like building a level 
graph, combining multiple graph traversal techniques and the concept of a 
blocking flow, which we will all get to.

So, what is Dinic's algorithm? It's a fast strongly polynomial maximum flow
algorithm. The fact that it's a strongly polynomial is important, it means that
the runtime doesn't depend on the capacity values of the flow graph, which for
all we know could be very large.
What's remarkable about Dinic's is that not only is it fast in practice for 
general graphs, but it also boasts performance on bipartite graphs running in a
time complexity of big O of sqrt root V times E. The importance of this cannot
be over stated: it makes it possible to handle bipartite graphs of a RIDICULOUS
size. If you are doing competitive programming, Dinic's is the defacto standard
algorithm to solve maximum flow problems.
The algorithm was conceived in 69 by Yee-fim Dinitz and published in 1970. The 
algorithm was later modified slightly and popularized in the West by Shy-mon
Even, mispronouncing Dinitz algorithm as Dinics algorithm.

Let's start talking about the algorithm itself, but first beginning with an
analogy. Suppose you and a friend planned to meet up at a coffee shop a few 
streets east of where you are. You have never been to this coffee shop and you
don't exactly know where it is, but you know it is somewhere east, how would 
you get there?

Q: With the information you have, would it make sense to head south? What 
about north west?

The only sensible directions are: east, north east and south east, this is
because you know that those directions guarantee that you make positive progress
towards the coffee shop.

This form of heuristic ensures that we continuously make progress towards
whatever place of interest we desire to go. How can we apply this to solving
for the maximum flow?

In this analogy, you are the source and the coffee shop is the sink. The main
idea behind Dinic’s algorithm is to GUIDE augmenting paths from s -> t using a
level graph, and in doing so greatly reducing the runtime.

The way Dinic’s determines which edges make progress towards the sink T and
which do not is by building what is called a level graph.

The levels of the graph are those obtained by doing a BFS from the source.

Furthermore, an edge is only part of the level graph if it makes progress 
towards the sink. That is, the edge must go from a node at level L to another
at level L+1.

The requirement that edges must go from L to L+1 prunes backwards and "sideways"
edges (grey edges in this slide).

As yourself, if we're trying to go from s -> t as quickly as possible, does it
make sense to take the red edge going in the backwards direction?

No, taking the red edge doesn’t bring you closer to the sink, so it should only
be taken if a detour is required. This is why backwards edges are omitted in
the level graph.

The same thing can be said about edges which cut across sideways across the same
level since no progress is made.

It’s also worth mentioning that residual edges can be made part of the level
graph, but they must have a remaining capacity, greater than 0.



