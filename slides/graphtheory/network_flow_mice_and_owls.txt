
Hello and welcome, my name is William,
Today we're going to use network flow to solve a problem. The problem we're 
going to tackle I called the "mice and owls" problem which is a slightly harder 
variation of another competitive programming problem which i'll link in the 
description. I love this problem because of its simple elegant solution and its
realistic application, let's have a look.

Suppose M mice are out on a field and thereâ€™s a hungry owl about to make a move.
Assume that the owl can reach every mouse.

Further suppose there are H holes scattered across the ground that the mice can
hide in (each having a certain capacity).

Every mouse is capable of running a radius of r before being caught by the owl.
The question asks what is the maximum number of mice that can hide safely?
If you want to attempt the problem, now is a good time to stop the video and
give it a go.

The first step is to figure out which holes each mouse can reach. Visualize this
by drawing a radius of r around each mouse, and if inside the radius there's a
hole or the circle touches a hole we'll assume the mouse can make it to that 
hole.

So if we draw an edge between a mouse and a hole if the mouse can make it to
that hole we get the following graph.

The next step is to actually match mice to holes to maximize the overall
safety of the group. By doing a simple quick inspection it's clear that not
every mouse should be matched to any hole.

For example, this orange mouse should probably not try to run to the hole with
capacity 3, because it's the only mouse that can reach the other hole behind it
with capacity 1.
Making any bad decision like that has the chance to jeopardize maximizing the
overall number of mice that can safely hide. 

The key realization to make is that this graph is bipartite; and once we know
that, it becomes a simpler task to setup the flow graph and run maximum flow to
maximize the overall number of mice which can make it to safety.

Here are the steps I would do to setup the flow graph to run max flow. First I
would create M mice nodes labeled zero through M-1 inclusive.

Then on the over side, I would create H nodes each representing a hole. I would
label, or index those nodes from M to M+H-1 inclusive to give them a different
id then the mouse nodes.

Then place an edge with a capacity of 1 between the mouse and the hole if the
mouse can reach the particular hole.

Connect an edge with capacity 1 from the source to each mouse node to indicate
that each node can have at most 1 mouse.

And lastly, connect an edge from the hole node to the sink with the capacity of
each hole.

The problem has now been transformed into a maximum flow problem. Run any 
max-flow algorithm and the maximum number of mice that are safe is equal to the
value of the max-flow. This is really neat, and it's worth looking at some
source code to really understand this setup and how it works.

Let's have a look at some source code for how to setup a problem like this.

Here we are in the source code. I've laid out some instructions up top here in
case you wanted to run or change the program yourself.

This program actually uses the Ford Fulkerson flow solver we saw two videos 
back, so I highly recommend you watch that video before continuing. I'll link
it in the description below in case you haven't.

So let's get started, the first thing I do is define a Mouse class, this is just
a wrapper around a point2D object. Effectively a mouse is just a point a plane.
I also do the same thing with a Hole class except that the Hole class also has a
capacity with addition to a point2D object.

Next up in the main method you see that I'm creating a bunch of mouse objects
and holes with various capacities and placing both of those in arrays.

The last thing I do in the main method is call the solve method which takes as
input the two arrays we just created and a radius. The radius is how far a mouse
can run from its current position before being caught by the owl.

The solve method is where things really start getting interesting. 
