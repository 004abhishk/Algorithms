Hello and welcome,

My name is William and today we are going to probe further into network flow
talking about a specific implementation of the Ford-Fulkerson method which is
the Edmonds-Karp algorithm. The Edmonds-Karp algorithm is another maximum flow
algorithm which, uses a different technique to find augmenting paths through
the flow graph.

Before we get started let me give you a refresher on what we're doing:
1) We are trying to find the maximum flow on a flow graph because we know that
finding the max flow is really useful for finding bipartite matchings and to 
solve a whole host of problems.

2) So far we have looked at one technique to find the max flow which is to use 
the Ford-Fulkerson method which at a high level says that all we want to do is
repeatedly find augmenting paths from s to t, augment the flow and repeat until
no more paths exist.

3) The key takeaway here is that the Ford-Fulkerson method does NOT specify HOW 
to actually find augmenting paths, so this is where optimization comes into play

[Ford-Fulkerson animation]
A few videos ago we saw what the Ford-Fulkerson method is, how it is used to 
find the maximum flow and how it can be implemented with a DFS.
[The flip graph animation]
However, we saw that the pitfall when using a DFS was that the time complexity
depends on the capacity of the edges in the graph. This is because the DFS picks
edges to traverse in such a way that we might only ever able to push one unit of
flow in each iteration.
This is really bad and can kill the time complexity even though it is unlikely 
to happen in practice, but it's something we absolutely want to avoid should it 
happen. Right now, the time complexity of the Ford-Fulkerson method with a DFS 
is O(E times f) where E is the number of edges and f is the maximum flow.

The idea behind Edmonds-Karp says that instead of using a DFS to find augmenting
paths, we should use a BFS instead to get a better time complexity of O(V times
E squared). O(V times E squared) may not look like a better time complexity, but
it actually is. What's different is that the time complexity while it may not 
be great does no depend on the capacity value of any edge in the flow graph, and
this is crucial. We call such an algorithm that doesn't depend on the actual
input values a strongly polynomial algorithm, and that's what Edmonds-Karp is.

The Edmonds-Karp algorithm can also be thought of as an algorithm which 
repeatedly finds the shortest augmenting path from s -> t, that is in terms of 
the number of edges used each iteration.
Using a BFS during Edmonds-Karp ensures that we find the shortest path -- this 
is a consequence of each edge being unweighted. I say unweighted, because as 
long as the edge has a positive capacity we don't distinguish between one edge
being any better or worse than any other edge.

Let's look at why we might care about using Edmonds-Karp. Suppose we have this
flow graph, and we want to find the maximum flow. If we're using a DFS we might
do something like this:

Start and the source

and do a random DFS going forwards

<press>

<press>

<press>

<press>

<press>

So after a lot of zigzagging through the flow graph we were able to find the 
sink. As we just saw, a DFS has the chance to cause long augmenting paths, and
longer paths are generally undesirable because the longer the path, the higher
the chance for a small bottleneck value which results in a longer runtime.

Finding the shortest path from s to t, again, in terms of the number of edges
as an augmenting path is a great approach to avoid the DFS worse case and reduce
the length of augmenting paths.

To find the shortest path from s to t do a Breadth First Search (BFS) starting
at the source and ending at the sink. While exploring the flow graph, remember
that we can only take an edge if the capacity of the edge is greater than 0.

In this example, all edges outwards from s have a remaining capacity greater
than 0, so we add all the neighbours to the queue and proceedâ€¦

Again, add all reachable neighbours to the queue and continue



