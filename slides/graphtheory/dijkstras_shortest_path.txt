[intro_sound] Hello and welcome! My name is william, today we're going to tackle Dijkstra's shortest path algorithm. This is one of the most important algorithms in graph theory for finding the shortest paths, so without further ado let's dive in.

The first thing to mention about Dijkstra's algorithm is that it is a single source shortest path algorithm for graphhs with non-negative edge weighhts. Thhis means thhat at the beginning of the algorithm you need to specify a starting node to indicate a relative starting point. Once you specify the starting node Dijkstra's can tell you thhe shortest path between that node and all other nodes in the graph which is pretty sweet.
Depending on how you implement your Dijkstra's and what data structures you use the time complexity is typically  O(E*log(V)) which is competitive against other SSSP algorithms we see around.

Before we go crazy trying to find shortest pathhs on various types of graphs you need to know that Dijkstra's requires thhat all edges of our graph have a non-negative weights. This constraint is imposed to ensure that once a node has been visited its optimal distance cannot be improved by finding a shorter path by taking an edge with a negative weight.
This is property is especially important because it enables Dijkstra’s algorithm to act in a greedy manner by always selecting the next most promising node.

For this slide deck, my goal is to help you understand how to implement Dijkstra’s algorithm, and also how to implement it very efficiently.
We're going to start by looking at the naive implementation because it's by far the most common and then we'll get into using an indexed PQ alongside the decreaseKey operation; and lastly I want to briefly mention how we can use a D-ary heap to further boost performance.

At a high level we can examine the steps required in executing Dijkstra's algorithm. First we'll need two bits of information, first is an array called 'dist' that keeps track of the shortest distance to every node from the start node. Initially this array is filled with the value positive infinity except for the index of the starting node which should be initialized to zero.
Additionally we'll need to maintain a PQ of key-value pairs of (node index, distance) pairs which tell you which node to visit next based on sorted min value.
At first insert the key-value pair (s, 0) into the PQ and loop while PQ is not empty pulling out the next most promising (node index, distance) pair as we go.
For each node we visit we'll want to iterate over all the outwards edges and relax each edge appending a new (node index, distance) key-value pair to the PQ for every relaxation.
We do this until our PQ is empty at which point the shortest distance to each node is known and stored in the 'dist' array we maintain.

That explanation was a little abstract, let's have a look at the simple example with a standard PQ. In all these examples assume node 0 is the starting node.

Boxed in red is the distance array I will be using to track the optimal distance from the start node to each node in the graph. At the beginning, the distance to every node is initialized to positive infinity since we assume every node is unreachable. If at the end of the algorithm there's still a value of infinity at a certain index we know that that node is unreachable.

Then on the right I will be maintaining key-value pairs corresponding to a node's index and the best distance to get to that node. This PQ will tell us which node we should visit next based on the which key-value pair has the lowest value.

To start with, assign a distance of zero to the start node at index 0 in the distance array. Also insert the key-value pair (0, 0) into the PQ to indicate that we intend on visiting node 0 with a best distance of 0.

Then the algorithm actually starts and we look inside the PQ for the first time and we discover that we should visit node 0.

From node 0 we can visit node 1 by using the edge with a cost of 4. This gives us a best distance of 4, so we can update our best distance from infinity to 4 in the 'dist' array. Also add this information to the PQ.

Next we can visit node 2 from node 0. Just like the last node we can update the optimal distance to reach node 2 from infinity to 1. Also add that node 2 is reachable with a distance of 1 to the PQ.

That concludes visiting all the edges for node 0. To decide which node to visit next Dijkstra's always selects the next most promising node in the PQ, so we can poll which node to visit next by extracting the best key-value pair.

Node 2 is the next most promising node because it has a distance of 1 from the start node while node 1 has a greater value of 4.

From node 2, if we take the upwards edge we can improve the best distance to node 1 by taking the current best distance from node 2, which is 1, plus the edge cost of 2 to get the node 1, for a total cost of 3, which is better than the previous value of 4. Every time we find a better distance to a node we need to insert that information into the PQ.

Then we can improve the best distance to node 3 to be 6.

<press>

The next most promising node is node 1

We can improve the best distance to node 3 by taking the edge from node 1 to node 3 with a cost of 1.

<press>

<press>

The next most promising node is node 1 with value 4, but we have already found a better route to get to node 1 since the 'dist' array at index 1 has value 3, therefore we can ignore this entry in the PQ. Having these duplicate key entries in the PQ is what constitutes making this implementation of Dijkstra's lazy because we lazily delete outdated key-value pairs.

Next up is node 3

Update the best value to node 4 to be 7

<press>

We already found a better route to node 3 so skip this entry in the PQ.

Finally visit node 4

That's all there is for the lazy implementation of Dijkstra's algorithm. There are only a few moving parts, but in large the only things to keep track of is the 'dist' array which contains the best distance so far from the start node to each other node and the PQ which tells you which node to visit next best of best value found so far.












[outro sound]


