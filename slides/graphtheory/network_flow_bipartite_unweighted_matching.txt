Hello my name is William,
Today we're going to start diving a little deeper into network flow.
We're going to talk about unweighted bipartite graph matching, and specifically
how we can use max flow to find a matching for us.

Before we get started though, I should mention what a bipartite graph is. A 
bipartite graph is one whose vertices can be split into two independent groups
U, V such that every edge connects between U and V.
Other definitions exist such as: The graph is two colourable or there is no
cycle with an odd length.

Bipartite graphs often arise when we're trying to match one group of items to 
another. 
  Think of situations like matching suitable candidates to jobs; there
could be multiple jobs and multiple candidates, but not every candidate is
suitable for each job. If jobs are red nodes and candidates white nodes then
there would be an edge between the two if the candidate is a good fit.
  Another situation could be matching surfers to surf boards. Suppose there are
multiple surfers and surf boards, but the surfers have preferences and 
requirements for their boards, such as color, size and so on. Then the same 
thing happens: we place an edge between the surfer and the surf board to 
indicate that they are able to be matched. 

Generally when we're setting up a bipartite graph we’re interested in what’s
called a Maximum Cardinality Bipartite Matching. This is when we’ve maximized
the pairs that can be matched with each other. 
For example, we've maximized the number of candidates that can be matched to 
jobs, or the number of boys and girls that are willing to  dance with each other
at the local school dance off; you get the idea.

Finding a matching is not unique to bipartite graphs, you can also have a
matching on a non-bipartite graph -- this variant is a lot harder to solve and
also much less common. Another variant is finding a maximum matching on a
weighted graph where you either minimize or maximize the cost of the maximum
matching, this variant is also much much harder to solve than the unweighted
version. In the unweighted version no edge is "better" in any sense than any
other edge so it makes finding a matching much easier.

We're mostly going to focus on this top left box right here which is the easiest
of the four variants, but hopefully we'll take poke at some of the other ones
too. So if you want to find a maximum matching on an unweighted bipartite graph
you have lots of options. You can either setup the graph as a flow problem and
push flow through it which is what we'll look at in this video, but you can also
repeatedly find augmenting paths which maximize the matching using a DFS or you
can use the Hopcroft-Karp algorithm.

If your edges are weighted and your graph is still bipartite, you also have a
lot of options. You can use a min-cost max-flow algorithm, or run the Hungarian
algorithm, and lastly there's the more sophisticated network simplex algorithm
using linear programming.

If however your graph is not bipartite but you edges are unweighted you can use
Edmond's blossom algorithm which is arguably non-trivial to code.

And lastly, the hardest of the four variants is when your graph is non-bipartite
and the edges are weighted. I didn't find much information about this online,
but the recommendation seems to be to use dynamic programming for small graphs.






The same thing can be said about pairing boys and girls at a school dance.
