Hello everybody, what's happening? My name is William and today we're talking 
about minimum spanning trees, and in particular how to use Prim's algorithm to
find them.

@3.
So, what is a minimum spanning tree? On a weighted graph, a minimum spanning 
tree (or MST for short) is a tree which spans the whole graph connecting all 
nodes together while minimizing the total edge cost. It's important to note that
your spanning tree cannot contain any cycles, otherwise it's not a tree.

@4.
Here's a weighted graph with nodes labeled 0 through 6 with various edges of 
different weights connecting them.

@5.
One possible minimum spanning tree is the following edges highlighted in green
whose edge costs sum to 9. There's no way to cannot all the nodes together and 
get a lower cost than this. Note that even though the minimum spanning tree in
this graph is unique in general it's possible for a graph to have multiple MSTs
of equal costs.

@6.
Hopefully you've been paying attention because now it's your turn. I'm going to
present you some weighted graphs and you need to identify any possible MST you
can. Let's begin with this graph; take a moment and find any MST on this graph.

<pause>

@7.
One possible MST is the following with a cost of 14. Again, MSTs are not unique
so there could be other valid minimum spanning trees, but they'll all have a 
cost of 14.

@8. 
Let's do another one, can you find a minimum spanning tree here? I'll give 
you a moment, but feel free to pause the video if you need.

<pause>

@9.
Here's a possible answer with the MST highlighted in green and a cost of 39

@10.
What about this graph? I promise it's the last one.

@11.
This is a bit of a trick question because there's no MST. All nodes must to 
connected on a single component for a spanning tree to exist.

@12.
Let's change focus and start talking about Prim's algorithm. Prim's is one of my
favorite MST algorithms because of how simple and intuitive it is. By nature its
a greedy algorithm which always selects the next best edge to add to the MST and
it works very well on dense graphs with lots of edges.
However, a few the downsides of Prim's is that it's not as easily parallelizable
as other well know MST algorithms and it's slightly harder but not impossible to
find the minimum spanning forest of a graph.
There are two well known versions of Prim's I want to discuss, the first is the 
more common lazy version which runs in big O of E log E, and then there's the
improved eager version which runs in big O of E log V but requires a slightly
different data structure.

@13.
Let's start by looking at the lazy version because it's easier to implement. 
Here's the general idea:
Maintain a PQ that sorts edges based on minimum edge cost. This PQ is used to 
tell you which node to go to next and what edge was used to get there.
Then the algorithm begins and we start on any starting node s and mark s as
visited and iterate over all its edges and add them to the PQ.
From this point on, while the PQ is not empty and a MST has not been formed,
dequeue the next best edge from the PQ. If the dequeued edge is not outdated
which it could be if we visit the node it points to via another path before 
getting to this edge then mark the current node as visited and add the selected
edge to the PQ. If you selected a stale outdated edge simply poll again.
Then repeat the process of iterating over the current node's edges and adding 
them to the PQ. While doing this care not to add edges which point to already
visited nodes, this will reduce the number of outdated edges in the PQ.

@14.
Let's have a look at an example, suppose we have this weighted undirected graph
and we want to find any MST. 

@15.
An important thing to keep in mind is that while the graph above represents an
undirected graph, our internal adjacency list representation has each undirected
edge stored as two directed edges.

@16.
The actual internal representation typically looks like this which is a lot
easier to work with.

@17.
Along with the graph, I will also be keeping track of the edges in the PQ on the
right. The edges objects in the PQ will be stored as triplets containing the
start node, end node and edge cost.

@18.
Lastly, I will be coloring nodes nodes has either blue for unvisited, orange for
visiting and gray for visited.

@19.
Let's begin Prim's on node 0.

@20.
Iterate over all outgoing edges and add them to the PQ

@21.
The first edge to go into the PQ is the edge from 0 to 1 with cost 10.

@22.
Then edge 0 to 2 with cost 1

@23.
And finally edge 0 to 3 with cost 4

@24. <nothing>
@25. <nothing>

@26.
Now we look in our PQ and poll the next most promising edge and add it to the 
MST. The edge from 0 to 2 with a cost of 1 has the lowest value in the PQ so it
gets added to the MST. This also means that the next node we process is node 2.

@27. <nothing>

@28.
Next, iterate through all the edges of node 2 and add them to the PQ.

@29. <nothing>
@30. <nothing>

@31.
While iterating over the outgoing edges of node 2 realize that we may encounter
edges which point to already visited nodes. We do NOT want to add these to the
PQ because they're of no use.

@32.
The reason we don't include edges which point to already visited nodes is that
either they overlap with an edge already part of the MST as is the case with the
edge on this slide or they would introduce a cycle in the MST if included.

@33. <nothing>

@34.
So the next best edge in the PQ is the edge from 2 to 3 with cost 2 so it gets
add to the MST. This also means that the next node we process is node 3.

@35. <nothing>

@36.
The same process of adding edges to the PQ and polling the smallest edge 
continues until the MST is complete. I'll let the animation play until something
interesting happens.

...

@62.
Notice that the next best edge we poll from the PQ is an edge which points to 
node 1 which is already visited. This means that the edge is outdated and stale
because we found a better cheaper path to node 1 already so we can safely ignore
this edge and poll again.

@63.
The next edge is also stale, so keep polling.

...

@71.
So what happens when we have two edges which have the same minimum cost in the 
PQ, which gets polled first? In practice it doesn't matter so let's assume it's
edge (2, 5, 8) because it was added to the PQ first.

@72.
That edge was stale so poll again.

@73.
The next edge is from 4 to 7 with cost 8.

@74. <nothing>
@75. <nothing>
@76. <nothing>
@77. <nothing>
@78. <nothing>

@79.
We can now stop Primâ€™s since the MST is complete. We know the MST is complete 
because the number of edges in the tree is one less than the number of nodes in
the graph; this is precisely the definition of a tree.

@80.
If we collapse the graph back into the undirected edge view it becomes clear 
which edges are included in the MST.

@81. <nothing>

@82.
To find the MST cost simply sum up the cost of all the edges which were selected
which totals to 20.

@83.
Great, now that we understand the gist of the lazy implementation of Prim's lets
have a look at some pseudo code. Let me first define a few variables we'll need:

@84.
First is 'n' the number of nodes in the graph.

@85.
The variable 'pq' represents the PQ data structure, it stores edge objects 
based on minimum edge cost. Each edge object consists of a start node, an end
node, and an edge cost.

@86.
Next is 'g' which represents the graph we're working with. 'g' represents an
adjacency list of weighted edges. In g, every undirected edge is represented as
two directed edges.
As a side node, if your graph is extremely dense you should probably prefer 
using an adjacency matrix instead of an adjacency list for efficiency.

@87.
And lastly is a visited boolean array of size n which tracks whether node i has
been visited or not.

@88.
So this is the whole algorithm for the lazy implementation, let's go over it
step by step.

@89.
The function takes one argument s which is the start node index, by default s is
set to node 0.

@90.
Then I define a few more variables we'll need:
'm' is a constant representing the number of expected edges in the MST
'edgeCount' is the number of edges we have currently included in the MST. This
variable is used to make sure the tree spans the whole graph.
'mstCost' tracks the total cost of the MST
and finally, 'mstEdges' is an array which holds edges which we have included in
the MST.

@91.
The first actual bit of logic we do is add all outgoing edges from s to the pq
with the addEdges method, let's have a look...

@92.
Here we are at the addEdges function.

@93.
The first thing I do is mark the current node as visited.

@94.
Next, I iterate over all the outgoing edges of the current node.

@95.
If the destination node of the edge is unvisited add it to the PQ.

@96. <nothing>

@97.
Once we've added the first set of edges to the PQ the algorithm really begins 
and we enter a while loop. While the PQ is not empty and the minimum spanning
tree is not complete keep iterating.

@98.
Then inside the loop we poll the next best edge out of the PQ and grab a 
reference to the destination node index, this is the node the edge is 
pointing at.

@99.
This next line is very important, it's the logic that skips adding an edge to 
the PQ if that edge points to an already visited node. Again, edges can become
stale or outdated in the PQ if the node they're pointing to becomes visited
via another path.

@100.
Next, actually add the edge to the MST by adding it to the mstEdges array. While
we're adding the edge to the tree also sum over the edge costs.

@101.
The last thing we want to do is call the addEdges method with the new current 
node. Recall that this will add all outgoing edges pointing to unvisited nodes
to the PQ.

@102
The very last thing is to make sure our tree spans the whole graph and return 
the edges comprising the MST along with the MST cost.

@103.
So that's all for the lazy implementation, now let's talk about the eager 
version and what optimization it brings.
The lazy implementation of Primâ€™s inserts E edges into the PQ. This results in
each poll operation on the PQ to be O(log(E)).
In the eager version we maintain the idea that instead of adding edges to the PQ
which could later become outdated as the algorithm continues to visit nodes that
we should instead track (node, edge) key-value pairs that can easily be updated
and polled to determine the next best edge to add to the MST.

@104.
for this all to make sense there's a key realization that needs to happen and 
that is that: for any MST with directed edges, each node is paired with
exactly one of its incoming edges (except for the start node).
One way to see this is on a MST with possibly multiple edges leaving a node, but
only ever one edge entering a node.

@105.
Let's have a closer look at what I mean. Suppose we have this undirected graph.

@106.
The equivalent directed version looks like this.

@107.
A possible MST starting at node 0 looks like the following.

@108.
Now notice that on this directed MST each node is paired with exactly one edge, 
well except the starting node.

@109.
So in a sense, there seems to be a relationship we can take advantage of here 
which is that each node is paired with exactly one incoming edge.

@110.
















