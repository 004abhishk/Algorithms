

Intro about watching the intro video


Alright, here we are in the source code written in Java, I have laid out some
instructions here in case you wanted to download the code, play around with it
and run it yourself.

If I scroll down, you can see that we still have the same setup as before with 
an Edge class and a NetworkFlowSolverBase we can inherit from. I have already 
previously covered these so I will not cover them with great detail, but there 
is one important change I have made since the FordFulkerson video.
In the NetworkFlowSolverBase, I have added three methods to abstract away 
visiting nodes and marking all nodes as unvisited. Now this is all done 
efficiently internally through the NetworkFlowSolverBase with a visitedToken
you don't have to worry about. It also helps readability for anyone new to the 
code. Alright, let's now have a look at the EdmondsKarpSolver.

First, notice that the EdmondsKarpSolver extends the NetworkFlowSolverBase, so 
we get a whole bunch of things for free from that including that ability to 
easily construct a flow graph before we push any flow through it.
In the constructor for the EdmondsKarpSolver, all I do is call the super class's
constructor. This performs various initializations, including allocating memory
for the flow graph, and registering which nodes are the source and the sink.

The most important method in the edmonds karp solver is the solve method which
gets called to find the maximum flow.
This method is really short, all we do is repeatedly find augmenting paths from
the source to the sink until the flow we get is zero at which point we know that
the graph is fully saturated and no more augmenting paths can be found.

incrementing the visitedToken is a way of saying "mark each node as unvisited"

Then we know the maxFlow is the sum of the bottleneck values, which I
capture through the flow variable, so we sum of that.
Let's take a closer look at the BFS method.