1) Hello and welcome back, my name is William and today's topic is the Breadth First Search graph traversal algorithm.

2) Alongside the DFS the BFS algorithm is another fundamental search algorithm used to explore nodes and edges of a graph. It runs in a time complexity of big O of V plus E, that is vertices plus edges and is often used as a building block in other algorithms. It differs from a DFS in the way it explores the graph.
The BFS algorithm is particularly useful for one thing: finding the shortest path on an unweighted graph.

3) A BFS starts at some arbitrary node in the graph and explores its neighbor nodes first before moving on to explore the next level of neighbors. In a sense a BFS explores nodes in layers, it does this by maintaining a queue of which node to visit next. This is most easily seen with an example.

4) Let's begin a BFS at node zero, so let's add node zero to our queue on the left.

... 

32) And that's how you do a BFS in a nutshell.

33) In the previous animation we relied on a queue to help to track which node we should visit next. Upon reaching a new node the algorithm adds it to the queue to visit it later. The queue data structure works just like a real world queue such as a waiting line at a restaurant. People can either enter the waiting line (enqueued) or get seated (dequeued).

34) Let's look at some Pseudo code for the BFS.

35) First things first, we'll need two variables:
- n the number of nodes in our graph
- and g, the adjacency list representing our unweighted graph.

36) This BFS function takes two arguments, s and e, the start and end nodes of the search. The return value for this function if the shortest path of nodes from s to e.

37) I've divided the function into two methods for simplificy, first we solve the problem by executing our BFS and then we reconstruct the path from s to e. So let's take a look at the solve method.

38) Here we are inside the solve method.

39) The first thing I do is initialize the queue data structure that we'll need and add the starting node to it. This queue should support at minimum the enqueue and dequeue operations.

40) Then initialize a boolean array with all false values and mark the starting node as visited.

41) The last thing we'll need is an array called prev which should initially be initialized to all null values. This prev array tracks the index of parent node that visited each node so we can reconstruct the shortest path at the end.

42) Loop while the queue is not empty and pull out the current node we're at from the queue by issuing a dequeue operation.

43) Then reach inside the adjacency list and get all the neighbours of this node.

44) Loop over each next unvisited node

45) Once we find a next unvisited node enqueue it to the queue, mark it as visited and keep track of the parent node in the prev array.

46) Once the queue is emtpy and our BFS is complete return the prev array.

47) <press>

48) Back inside the BFS method, take the output of the solve method which gave us the prev array and call the reconstruct path method.

49) The reconstruct path method is very simple, let's take a quick look.

50) The first thing we do is actually reconstruct the path by looping backwards from the end node and making our way back to the start node, assuming we can reach it. The reason the prev array had to be initialized to all null values is because the way i'm checking whether or not the for loop should stop is by verifying if the position we're at in the prev is null.

51) Since we looped through the prev array backwards we have the reverse the order of the nodes so that the path starts at the start node and ends at the end node.

52) Last, but not least, we actually have the make sure the path between nodes s and e exits, because if it doesn't we should return an empty path.












